<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payslip Data Breakdown</title>
  <!-- Load Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Load Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --base: #1e1e2e;
      --mantle: #181825;
      --crust: #11111b;
      --text: #cdd6f4;
      --subtext: #bac2de;
      --surface0: #313244;
      --surface1: #45475a;
      --surface2: #585b70;
      --green: #a6e3a1;
      --blue: #89b4fa;
      --yellow: #f9e2af;
      --red: #f38ba8;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--base);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      background-color: var(--mantle);
      padding: 2rem 1rem;
      text-align: center;
      border-bottom: 1px solid var(--surface1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    header h1 {
      font-family: 'Inter', sans-serif;
      font-size: 2rem;
      font-weight: 600;
      color: var(--text);
    }

    .file-label {
      display: inline-block;
      margin-top: 1.5rem;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      background-color: var(--surface1);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
      user-select: none;
    }
    .file-label:hover {
      background-color: var(--surface2);
    }

    input[type="file"] {
      display: none;
    }

    .chart-container {
      max-width: 1000px;
      margin: 2.5rem auto;
      background-color: var(--mantle);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    canvas {
      width: 100% !important;
      height: 400px !important;
    }

    #chartjs-tooltip {
      background: var(--mantle);
      color: var(--text);
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      padding: 8px;
      transition: all 0.1s ease;
      font-family: 'Inter', sans-serif;
      font-size: 0.8rem;
      line-height: 1.2;
      pointer-events: none;
      white-space: nowrap;
    }

    #chartjs-tooltip .title {
      font-weight: bold;
      margin-bottom: 6px;
    }

    #chartjs-tooltip .section-title {
      font-weight: bold;
      margin-top: 8px;
      margin-bottom: 4px;
    }

    #chartjs-tooltip .breakdown-item {
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <header>
    <h1>Payslip Data Breakdown</h1>
    <label for="jsonUpload" class="file-label">Select JSON File</label>
    <input type="file" id="jsonUpload" accept="application/json" /><br><br>
    <p>(This tool runs locally in your browser. No data is uploaded.)</p>
  </header>

  <div id="onloadWrapper" style="display:none">
    <div class="chart-container">
      <canvas id="paymentChart"></canvas>
    </div>

    <div id="chartjs-tooltip" style="opacity:0; position:absolute; pointer-events:none;"></div>

    <div class="breakdown-container" style="max-width:1000px; margin:2rem auto; color: var(--text);">
      <label for="yearSelect" style="font-weight:500; margin-right:0.5rem;">Select Year:</label>
      <select id="yearSelect" style="padding:0.5rem; border: none; border-radius:4px; background:var(--surface1); color:var(--text);">
        <!-- options injected by JS -->
      </select>
      <div id="breakdownDetails" style="margin-top:1.5rem;"></div>
    </div>
  </div>

  <script>
    // Get CSS variable colors
    const rootStyle = getComputedStyle(document.documentElement);
    const themeColors = {
      text: rootStyle.getPropertyValue('--text').trim(),
      subtext: rootStyle.getPropertyValue('--subtext').trim(),
      surface0: rootStyle.getPropertyValue('--surface0').trim(),
      green: rootStyle.getPropertyValue('--green').trim(),
      blue: rootStyle.getPropertyValue('--blue').trim(),
      yellow: rootStyle.getPropertyValue('--yellow').trim(),
      red: rootStyle.getPropertyValue('--red').trim(),
    };

    // Configure Chart.js defaults
    Chart.defaults.font.family = 'Inter, sans-serif';
    Chart.defaults.color = themeColors.text;

    let allSlips = [];
    let paymentChart;

    function initChart(slips) {
      if (paymentChart instanceof Chart) {
        paymentChart.destroy();
      }

      allSlips = slips;
      const ctx = document.getElementById('paymentChart');

      paymentChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              title: { display: true, text: 'Check Date', color: themeColors.subtext },
              ticks: { color: themeColors.text, maxRotation: 45, minRotation: 45 },
              grid: { color: themeColors.surface0 },
            },
            y: {
              stacked: true,
              title: { display: true, text: 'Amount (USD)', color: themeColors.subtext },
              ticks: { color: themeColors.text, callback: v => '$' + v.toLocaleString(undefined, {minimumFractionDigits: 2}) },
              grid: { color: themeColors.surface0 },
            }
          },
          plugins: {
            tooltip: {
              enabled: false,
              external: function (context) {
                // Tooltip Element
                const tooltipEl = document.getElementById('chartjs-tooltip');
                const tooltipModel = context.tooltip;

                // Hide if no tooltip
                if (tooltipModel.opacity === 0) {
                  tooltipEl.style.opacity = 0;
                  return;
                }

                // Set caret position classes (top/bottom)
                tooltipEl.classList.remove('above','below','no-transform');
                if (tooltipModel.yAlign) {
                  tooltipEl.classList.add(tooltipModel.yAlign);
                } else {
                  tooltipEl.classList.add('no-transform');
                }

                // Build the HTML
                let html = '';

                // **1) Title (the Check Date)**
                tooltipModel.title.forEach(function(title) {
                  html += `<div class="title">Payslip - ${title}</div>`;
                });

                const begin = slips[tooltipModel.dataPoints[0].dataIndex]['Payslip Information']['Pay Period Begin']
                const end = slips[tooltipModel.dataPoints[0].dataIndex]['Payslip Information']['Pay Period End']
                html += `
                  <div class="breakdown-item" style="margin-bottom:1em">
                    <span><em>${begin} - ${end}</em></span>
                  </div>
                `;

                // **2) Main value line (dataset label + value)**
                tooltipModel.dataPoints.forEach(dp => {
                  const label = dp.dataset.label;
                  const val   = dp.raw;
                  const total = context.chart.data.datasets
                    .reduce((sum, ds) => sum + (ds.data[dp.dataIndex] || 0), 0);
                  const pct = ((val / total) * 100).toFixed(1);
                  html += `
                    <div class="breakdown-item">
                      <span style="padding-right:10px"><b>${label}</b></span>
                      <span>$${val.toLocaleString(undefined, {minimumFractionDigits: 2})} (${pct}%)</span>
                    </div>
                  `;
                });

                // **3) Breakdown section**
                // Find which bar we’re on:
                const idx   = tooltipModel.dataPoints[0].dataIndex;
                const label = tooltipModel.dataPoints[0].dataset.label;
                const slip  = slips[idx];

                // Pick the right array:
                let items = [];
                if (label === 'Net Pay') {
                  items = slip['Earnings'] || [];
                } else if (label === 'Employer Paid Benefits') {
                  items = slip['Employer Paid Benefits'] || [];
                } else if (label === 'Deductions') {
                  items = [
                    ...(slip['Pre Tax Deductions']  || []),
                    ...(slip['Post Tax Deductions'] || [])
                  ];
                } else if (label === 'Taxes') {
                  items = slip['Employee Taxes'] || [];
                }

                if (items.length) {
                  html += `<div class="section-title">Breakdown</div>`;
                  items.forEach(item => {
                    // use Amount or fallback to YTD
                    const amt = (item.Amount != null ? item.Amount : item.YTD != null ? item.YTD : 0);
                    html += `
                      <div class="breakdown-item">
                      <span style="padding-right: 10px">${item.Description.substring(0, 30)}</span>
                      <span>$${amt.toLocaleString(undefined,{minimumFractionDigits:2})}</span>
                      </div>`;
                  });
                }

                tooltipEl.innerHTML = html;

                // **4) Position it**
                const canvasRect = context.chart.canvas.getBoundingClientRect();
                tooltipEl.style.opacity = 1;
                tooltipEl.style.left    = canvasRect.left + window.pageXOffset + tooltipModel.caretX + 'px';
                tooltipEl.style.top     = canvasRect.top  + window.pageYOffset + tooltipModel.caretY + 'px';
              }
            },
            legend: {
              labels: { color: themeColors.text },
              position: 'bottom',
            }
          }
        }
      });
    }

    function updateChart(slips) {
      // extract check‑dates sorted ascending
      const sorted = [...slips].sort((a,b) =>
        new Date(a['Payslip Information']['Check Date'])
          - new Date(b['Payslip Information']['Check Date'])
      );
      const labels = slips.map(s => s['Payslip Information']['Check Date']);

      const rawEarnings = slips.map(s => s['Earnings']
        .map(e => e.Amount || 0).reduce((a, b) => a + b, 0)
      );
      const benefitsData = slips.map(s => (s['Employer Paid Benefits'] || [])
        .map(b => b.Amount || 0).reduce((a, b) => a + b, 0)
      );

      const taxesData = slips.map(s => s['Employee Taxes']
        .map(t => (t.Amount || 0)).reduce((a, b) => a + b, 0)
      );
      const preDeductions = slips.map(s => (s['Pre Tax Deductions'] || [])
        .map(d => (d.Amount || 0)).reduce((a, b) => a + b, 0)
      );
      const postDeductions = slips.map(s => (s['Post Tax Deductions'] || [])
        .map(d => (d.Amount || 0)).reduce((a, b) => a + b, 0)
      );
      const deductionsData = preDeductions.map((v, i) => v + postDeductions[i]);

      paymentChart.data.labels = labels;
      paymentChart.data.datasets = [
        {
          label: 'Net Pay',
          backgroundColor: themeColors.green,
          data: rawEarnings.map((v, i) => v - deductionsData[i] - taxesData[i] + Math.min(benefitsData[i], 0)),
          stack: 'stack1'
        },
        {
          label: 'Employer Paid Benefits',
          backgroundColor: themeColors.blue,
          data: benefitsData.map((v, i) => Math.max(v, 0)),
          stack: 'stack1'
        },
        {
          label: 'Deductions',
          backgroundColor: themeColors.yellow,
          data: deductionsData.map((v, i) => Math.max(v, 0)),
          stack: 'stack1'
        },
        {
          label: 'Taxes',
          backgroundColor: themeColors.red,
          data: taxesData.map((v, i) => Math.max(v, 0)),
          stack: 'stack1'
        }
      ];

      paymentChart.update();
    }

    document.getElementById('jsonUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();

      reader.onload = function(evt) {
        const data = JSON.parse(evt.target.result);
        const slips = data.Payslips || [];

        document.getElementById('onloadWrapper').style.display = 'block';

        initChart(slips);

        // 1) extract all years from your slips
        const years = Array.from(new Set(
          slips.map(s => {
            // assumes Check Date is MM/DD/YYYY
            const parts = s['Payslip Information']['Check Date'].split('/');
            return parts[2];
          })
        )).sort();

        // 2) populate the dropdown
        const yearSelect = document.getElementById('yearSelect');

        // create and append the “All Time” option
        const optAll = document.createElement('option');
        optAll.value = 'all';
        optAll.textContent = 'All Time';
        yearSelect.appendChild(optAll);

        years.forEach(y => {
          const opt = document.createElement('option');
          opt.value = y;
          opt.textContent = y;
          yearSelect.appendChild(opt);
        });

        // 3) helper to compute aggregates per section
        function computeAggregates(slipsForYear) {
          const sections = {
            'Earnings': s => s['Earnings'] || [],
            'Employer Paid Benefits': s => s['Employer Paid Benefits'] || [],
            'Employee Taxes': s => s['Employee Taxes'] || [],
            'Pre Tax Deductions': s => s['Pre Tax Deductions'] || [],
            'Post Tax Deductions': s => s['Post Tax Deductions'] || []
          };

          const result = {};

          // assume slipsForYear is already in chronological order by Check Date
          slipsForYear.sort((a, b) => new Date(a['Payslip Information']['Check Date']) - new Date(b['Payslip Information']['Check Date']));

          for (const [secName, getter] of Object.entries(sections)) {
            // temp store: { [description]: { sum: Number, lastYtd: Number|null } }
            const temp = {};

            slipsForYear.forEach(slip => {
              const items = getter(slip);
              items.forEach(item => {
                const desc = item.Description;
                const amt  = item.Amount  != null ? +item.Amount  : null;
                const ytd  = item.YTD     != null ? +item.YTD     : null;

                if (!temp[desc]) {
                  temp[desc] = { sum: 0, lastYtd: null };
                }

                if (amt != null) {
                  temp[desc].sum += amt;
                }
                if (ytd != null) {
                  // always overwrite—later slips replace earlier
                  temp[desc].lastYtd = ytd;
                }
              });
            });

            // build final map: prefer sum if >0, else fallback to lastYtd
            const finalMap = {};
            Object.entries(temp).forEach(([desc, { sum, lastYtd }]) => {
              const value = (sum > 0)
                ? sum
                : (lastYtd != null ? lastYtd : 0);
              finalMap[desc] = value;
            });

            result[secName] = finalMap;
          }

          return result;
        }

        // 4) render the breakdown into the page
        function renderBreakdown(aggregates) {
          const container = document.getElementById('breakdownDetails');
          container.innerHTML = '';  // clear previous
          for (const [secName, aggMap] of Object.entries(aggregates)) {
            // section title
            const h2 = document.createElement('h2');
            h2.textContent = secName;
            h2.style.marginTop = '1rem';
            container.appendChild(h2);

            // if no items, show placeholder
            if (Object.keys(aggMap).length === 0) {
              const p = document.createElement('p');
              p.textContent = 'No data for this section.';
              container.appendChild(p);
              continue;
            }

            // build a table
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.innerHTML = `
              <thead>
                <tr>
                  <th style="text-align:left; border-bottom:1px solid var(--surface2); padding:4px;">Description</th>
                  <th style="text-align:right; border-bottom:1px solid var(--surface2); padding:4px;">Total</th>
                </tr>
              </thead>
              <tbody>
                ${Object.entries(aggMap)
                  .sort((a, b) => b[1] - a[1])
                  .map(([desc, total]) =>
                    `<tr>
                       <td style="padding:4px;">${desc}</td>
                       <td style="padding:4px; text-align:right;">$${total.toLocaleString(undefined, {minimumFractionDigits:2})}</td>
                     </tr>`
                  ).join('')}
              </tbody>
            `;

            // section total
            const sectionTotal = document.createElement('tfoot');
            sectionTotal.innerHTML = `
              <tr style="padding-top:25px">
                <td style="padding:4px;"><b>Section Total</b></td>
                <td style="padding:4px;
                text-align:right"><em>$${Object.entries(aggMap).reduce((sum, x) => sum + x[1], 0).toLocaleString(undefined, {minimumFractionDigits:2})}</em></td>
              </tr>
            `;
            table.appendChild(sectionTotal);

            container.appendChild(table);
          }
        }

        // 5) wire dropdown to re‑compute on change
        function updateForYear(year) {
          let slipsForYear;
          if (year === 'all') {
            // use every slip
            slipsForYear = slips;
          } else {
            // filter by Check Date ending in "/YYYY"
            slipsForYear = slips.filter(s =>
              s['Payslip Information']['Check Date'].endsWith('/' + year)
            );
          }

          // now compute and render exactly as before
          updateChart(slipsForYear);
          const aggs = computeAggregates(slipsForYear);
          renderBreakdown(aggs);
        }

        // initialize to all time
        yearSelect.addEventListener('change', () => updateForYear(yearSelect.value));
        yearSelect.value = 'all';
        updateForYear('all');
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
