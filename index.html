<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payslip Data Breakdown</title>
  <!-- Load Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Load Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --base: #1e1e2e;
      --mantle: #181825;
      --crust: #11111b;
      --text: #cdd6f4;
      --subtext: #bac2de;
      --surface0: #313244;
      --surface1: #45475a;
      --surface2: #585b70;
      --green: #a6e3a1;
      --blue: #89b4fa;
      --yellow: #f9e2af;
      --red: #f38ba8;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--base);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      background-color: var(--mantle);
      padding: 2rem 1rem;
      text-align: center;
      border-bottom: 1px solid var(--surface1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    header h1 {
      font-family: 'Inter', sans-serif;
      font-size: 2rem;
      font-weight: 600;
      color: var(--text);
    }

    .file-label {
      display: inline-block;
      margin-top: 1.5rem;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      background-color: var(--surface1);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
      user-select: none;
    }
    .file-label:hover {
      background-color: var(--surface2);
    }

    input[type="file"] {
      display: none;
    }

    .chart-container {
      max-width: 1000px;
      margin: 2.5rem auto;
      background-color: var(--mantle);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    canvas {
      width: 100% !important;
      height: 400px !important;
    }
  </style>
</head>
<body>
  <header>
    <h1>Payslip Data Breakdown</h1>
    <label for="jsonUpload" class="file-label">Select JSON File</label>
    <input type="file" id="jsonUpload" accept="application/json" /><br><br>
    <p>(This tool runs locally in your browser. No data is uploaded.)</p>
  </header>
  <div class="chart-container">
    <canvas id="paymentChart"></canvas>
  </div>

  <div class="breakdown-container" style="max-width:1000px; margin:2rem auto; color: var(--text);">
    <label for="yearSelect" style="font-weight:500; margin-right:0.5rem;">Select Year:</label>
    <select id="yearSelect" style="padding:0.5rem; border: none; border-radius:4px; background:var(--surface1); color:var(--text);">
      <!-- options injected by JS -->
    </select>
    <div id="breakdownDetails" style="margin-top:1.5rem;"></div>
  </div>

  <script>
    // Get CSS variable colors
    const rootStyle = getComputedStyle(document.documentElement);
    const themeColors = {
      text: rootStyle.getPropertyValue('--text').trim(),
      subtext: rootStyle.getPropertyValue('--subtext').trim(),
      surface0: rootStyle.getPropertyValue('--surface0').trim(),
      green: rootStyle.getPropertyValue('--green').trim(),
      blue: rootStyle.getPropertyValue('--blue').trim(),
      yellow: rootStyle.getPropertyValue('--yellow').trim(),
      red: rootStyle.getPropertyValue('--red').trim(),
    };

    // Configure Chart.js defaults
    Chart.defaults.font.family = 'Inter, sans-serif';
    Chart.defaults.color = themeColors.text;

    document.getElementById('jsonUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        const data = JSON.parse(evt.target.result);
        const slips = data.Payslips;
        const labels = slips.map(s => s['Payslip Information']['Check Date']);

        const rawEarnings = slips.map(s => s['Earnings']
          .map(e => e.Amount || 0).reduce((a, b) => a + b, 0)
        );
        const benefitsData = slips.map(s => (s['Employer Paid Benefits'] || [])
          .map(b => b.Amount || 0).reduce((a, b) => a + b, 0)
        );

        const taxesData = slips.map(s => s['Employee Taxes']
          .map(t => (t.Amount || 0)).reduce((a, b) => a + b, 0)
        );
        const preDeductions = slips.map(s => (s['Pre Tax Deductions'] || [])
          .map(d => (d.Amount || 0)).reduce((a, b) => a + b, 0)
        );
        const postDeductions = slips.map(s => (s['Post Tax Deductions'] || [])
          .map(d => (d.Amount || 0)).reduce((a, b) => a + b, 0)
        );
        const deductionsData = preDeductions.map((v, i) => v + postDeductions[i]);

        if (window.paymentChart instanceof Chart) {
          window.paymentChart.destroy();
        }

        const ctx = document.getElementById('paymentChart');
        window.paymentChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Take Home Pay',
                backgroundColor: themeColors.green,
                data: rawEarnings.map((v, i) => v - deductionsData[i] - taxesData[i] + Math.min(benefitsData[i], 0)),
                stack: 'stack1'
              },
              {
                label: 'Employer Paid Benefits',
                backgroundColor: themeColors.blue,
                data: benefitsData.map((v, i) => Math.max(v, 0)),
                stack: 'stack1'
              },
              {
                label: 'Deductions',
                backgroundColor: themeColors.yellow,
                data: deductionsData.map((v, i) => Math.max(v, 0)),
                stack: 'stack1'
              },
              {
                label: 'Taxes',
                backgroundColor: themeColors.red,
                data: taxesData.map((v, i) => Math.max(v, 0)),
                stack: 'stack1'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true,
                title: { display: true, text: 'Check Date', color: themeColors.subtext },
                ticks: { color: themeColors.text, maxRotation: 45, minRotation: 45 },
                grid: { color: themeColors.surface0 },
              },
              y: {
                stacked: true,
                title: { display: true, text: 'Amount (USD)', color: themeColors.subtext },
                ticks: { color: themeColors.text, callback: v => '$' + v.toLocaleString() },
                grid: { color: themeColors.surface0 },
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  // preserve your existing label callback
                  label: function(ctx) {
                    const label = ctx.dataset.label;
                    const val   = ctx.parsed.y;
                    const total = ctx.chart.data.datasets
                                      .reduce((sum, ds) => sum + (ds.data[ctx.dataIndex]||0), 0);
                    const pct   = ((val/total)*100).toFixed(1);
                    return `${label}: $${val.toLocaleString()} (${pct}% of $${total.toLocaleString()})`;
                  },
                  // **new** footer callback to show breakdown
                  footer: function(tooltipItems) {
                    const idx   = tooltipItems[0].dataIndex;
                    const label = tooltipItems[0].dataset.label;
                    let items   = [];

                    // pick the right array off the slip
                    const slip = slips[idx];
                    if (label === 'Take Home Pay') {
                      items = slip['Earnings'] || [];
                    } else if (label === 'Employer Paid Benefits') {
                      items = slip['Employer Paid Benefits'] || [];
                    } else if (label === 'Deductions') {
                      items = [
                        ...(slip['Pre Tax Deductions']  || []),
                        ...(slip['Post Tax Deductions'] || [])
                      ];
                    } else if (label === 'Taxes') {
                      items = slip['Employee Taxes'] || [];
                    }

                    if (!items.length) {
                      return []; // no footer
                    }

                    // build lines: first “Breakdown:”, then each desc
                    const lines = ['Breakdown:'];
                    items.forEach(item => {
                      const amt = item.Amount != null
                        ? item.Amount
                        : (item.YTD != null ? item.YTD : 0);
                      lines.push(
                        `${item.Description}: $${amt.toLocaleString(undefined,{minimumFractionDigits:2})}`
                      );
                    });
                    return lines;
                  }
                },
                // make sure footer is shown
                footerFontStyle: 'normal'
              },
              legend: {
                labels: { color: themeColors.text },
                position: 'bottom',
              }
            }
          }
        });

        // 1) extract all years from your slips
        const years = Array.from(new Set(
          slips.map(s => {
            // assumes Check Date is MM/DD/YYYY
            const parts = s['Payslip Information']['Check Date'].split('/');
            return parts[2];
          })
        )).sort();

        // 2) populate the dropdown
        const yearSelect = document.getElementById('yearSelect');

        // create and append the “All Time” option
        const optAll = document.createElement('option');
        optAll.value = 'all';
        optAll.textContent = 'All Time';
        yearSelect.appendChild(optAll);

        years.forEach(y => {
          const opt = document.createElement('option');
          opt.value = y;
          opt.textContent = y;
          yearSelect.appendChild(opt);
        });

        // 3) helper to compute aggregates per section
        function computeAggregates(slipsForYear) {
          const sections = {
            'Earnings': s => s['Earnings'] || [],
            'Employer Paid Benefits': s => s['Employer Paid Benefits'] || [],
            'Employee Taxes': s => s['Employee Taxes'] || [],
            'Pre Tax Deductions': s => s['Pre Tax Deductions'] || [],
            'Post Tax Deductions': s => s['Post Tax Deductions'] || []
          };

          const result = {};

          // assume slipsForYear is already in chronological order by Check Date
          slipsForYear.sort((a, b) => new Date(a['Payslip Information']['Check Date']) - new Date(b['Payslip Information']['Check Date']));

          for (const [secName, getter] of Object.entries(sections)) {
            // temp store: { [description]: { sum: Number, lastYtd: Number|null } }
            const temp = {};

            slipsForYear.forEach(slip => {
              const items = getter(slip);
              items.forEach(item => {
                const desc = item.Description;
                const amt  = item.Amount  != null ? +item.Amount  : null;
                const ytd  = item.YTD     != null ? +item.YTD     : null;

                if (!temp[desc]) {
                  temp[desc] = { sum: 0, lastYtd: null };
                }

                if (amt != null) {
                  temp[desc].sum += amt;
                }
                if (ytd != null) {
                  // always overwrite—later slips replace earlier
                  temp[desc].lastYtd = ytd;
                }
              });
            });

            // build final map: prefer sum if >0, else fallback to lastYtd
            const finalMap = {};
            Object.entries(temp).forEach(([desc, { sum, lastYtd }]) => {
              const value = (sum > 0)
                ? sum
                : (lastYtd != null ? lastYtd : 0);
              finalMap[desc] = value;
            });

            result[secName] = finalMap;
          }

          return result;
        }

        // 4) render the breakdown into the page
        function renderBreakdown(aggregates) {
          const container = document.getElementById('breakdownDetails');
          container.innerHTML = '';  // clear previous
          for (const [secName, aggMap] of Object.entries(aggregates)) {
            // section title
            const h3 = document.createElement('h3');
            h3.textContent = secName;
            h3.style.marginTop = '1rem';
            container.appendChild(h3);

            // if no items, show placeholder
            if (Object.keys(aggMap).length === 0) {
              const p = document.createElement('p');
              p.textContent = 'No data for this section.';
              container.appendChild(p);
              continue;
            }

            // build a table
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.innerHTML = `
              <thead>
                <tr>
                  <th style="text-align:left; border-bottom:1px solid var(--surface2); padding:4px;">Description</th>
                  <th style="text-align:right; border-bottom:1px solid var(--surface2); padding:4px;">Total</th>
                </tr>
              </thead>
              <tbody>
                ${Object.entries(aggMap)
                  .map(([desc, total]) =>
                    `<tr>
                       <td style="padding:4px;">${desc}</td>
                       <td style="padding:4px; text-align:right;">$${total.toLocaleString(undefined, {minimumFractionDigits:2})}</td>
                     </tr>`
                  ).join('')}
              </tbody>
            `;
            container.appendChild(table);
          }
        }

        // 5) wire dropdown to re‑compute on change
        function updateForYear(year) {
          let slipsForYear;
          if (year === 'all') {
            // use every slip
            slipsForYear = slips;
          } else {
            // filter by Check Date ending in "/YYYY"
            slipsForYear = slips.filter(s =>
              s['Payslip Information']['Check Date'].endsWith('/' + year)
            );
          }

          // now compute and render exactly as before
          const aggs = computeAggregates(slipsForYear);
          renderBreakdown(aggs);
        }

        // initialize to all time
        yearSelect.addEventListener('change', () => updateForYear(yearSelect.value));
        yearSelect.value = 'all';
        updateForYear('all');
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
